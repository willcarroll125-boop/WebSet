import json
import re
import csv
from bs4 import BeautifulSoup
from collections import Counter
import matplotlib.pyplot as plt
from pdfgen import generate_pdf

def scan_file(file):
    with open(file, "r") as f:
        html_code = f.read()
    html_clean = BeautifulSoup(html_code, "html.parser")

    issues = []
    issues.extend(BrokenAccessControl(html_clean))
    issues.extend(CryptographicFailures(html_clean))
    issues.extend(sql_Injection(html_clean))
    issues.extend(InsecureDesign(html_clean))
    issues.extend(SecurityMisconfiguration(html_clean))
    issues.extend(Identification_and_Authentication_failures(html_clean))
    issues.extend(SSRF(html_clean))
    issues.extend(Vulnerable_and_Outdated_Components(html_clean))


    return {"issues": issues}

#@ francesca when you choose a vulnerability to start defining add it beneath line11 from the list below

#Vulnerability Scanners Go Here

def BrokenAccessControl(html_clean):
    issues = []
    for div in html_clean.find_all("div", id=True):
        if "admin" in div.get("id", "").lower():
            issues.append({
                "Threat": "Broken Access Control","Threat Severity": "High","Message": "Hidden admin functionality found in page."
            })

    for inp in html_clean.find_all("input", {"type": "hidden"}):
        if any(k in inp.get("name","").lower() for k in ["key","token","secret","api"]):
            issues.append({
                "Threat": "Broken Access Control","Threat Severity": "High","Message": "Hardcoded credential or API key found in form."
            })
    for a in html_clean.find_all("a", href=True):
        if re.search(r"/user/\w+|/admin/\w+", a["href"].lower()):
            issues.append({
                "Threat": "Broken Access Control","Threat Severity": "Medium","Message": f"Direct object reference in link: {a['href']}"
            })
    return issues

def CryptographicFailures(html_clean):
    issues = []
    CF = html_clean.find_all("script")
    for C in CF:
        code = C.get_text() or ""
        lower = code.lower()
        for algorithm in ["md5", "sha1", "des", "3des", "rc4"]:
            if algorithm in lower:
                issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "High", "Message": f"Depreciated algorithm detected: {algorithm.upper()}"})

        if "btoa(" in lower or "atob(" in lower:
            issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "Medium",
                       "Message": "Use of bota()/atob() has been detected."})
        if "math.random(" in lower:
            issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "Medium",
                       "Message": "math.random() has been used"})

        if "localstorage" in lower or "sessionstorage" in lower:
            issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "Medium", "Message": "Web storage used, review if data stored is sensitive."})


        hk = re.search(r"\b(const|let|var)\s+([A-Za-z0-9_]+)\s*=\s*['\"].+['\"]", code)
        if hk:
            kss = hk.group(2).lower()
            if any(word in kss for word in ["key","salt","secret"]):
                issues.append({
                "Threat": "Cryptographic Failure", "Threat Severity": "Medium", "Message": f"Hardcoded credential found in variable:'{kss}'"
            })
    return issues

def sql_Injection(html_clean):
    issues = []
    sql_patterns = [r"select\s+.+\s+from", r"insert\s+into", r"update\s+\w+\s+set",
                    r"delete\s+from", r"drop\s+table", r"union\s+select"]
    tpl = re.compile(r"\{\{\s*[\w\.\-]+\s*\}\}")  # {{placeholder}}

    for script in html_clean.find_all("script"):
        code = script.get_text() or ""
        lower = code.lower()
        for p in sql_patterns:
            if re.search(p, lower):
                issues.append({"Threat":"SQL Injection","Threat Severity":"High",
                               "Message":f"Possible SQL statement in <script>: '{p}'"})
        if tpl.search(code):
            issues.append({"Threat":"SQL Injection","Threat Severity":"High",
                           "Message":"Template placeholder in <script> â€” untrusted data in JS."})

    for tag in html_clean.find_all(True):
        for attr, val in tag.attrs.items():
            s = str(val)
            low = s.lower()
            for frag in ["select ","insert ","update ","delete ","drop ","union "]:
                if frag in low:
                    issues.append({"Threat":"SQL Injection","Threat Severity":"Medium",
                                   "Message":f"SQL-like text in attribute '{attr}'."})
            if tpl.search(s):
                if attr == "value" or tag.name in ("input","textarea") or (attr=="href" and low.strip().startswith("javascript:")):
                    sev="High"
                else:
                    sev="Medium"
                issues.append({"Threat":"SQL Injection","Threat Severity":sev,
                               "Message":f"Template placeholder in '{attr}' of <{tag.name}>."})
    return issues


def InsecureDesign(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        if "todo" in code or "fixme" in code:
            issues.append({
                "Threat": "Insecure Design",
                "Threat Severity": "Low",
                "Message": "Development note (TODO/FIXME) found in script."
            })
        if "debug" in code or "console.log" in code:
            issues.append({
                "Threat": "Insecure Design",
                "Threat Severity": "Medium",
                "Message": "Debug statements present in production code." })
    for comment in html_clean.find_all(string=lambda t: isinstance(t, str) and "<!--" in t):
        if "password" in comment.lower() or "secret" in comment.lower():
            issues.append({
                "Threat": "Insecure Design",
                "Threat Severity": "High",
                "Message": "Sensitive info mentioned in HTML comments." })
    return issues

def SecurityMisconfiguration(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        if "disable security" in code or "allow all origins" in code:
            issues.append({
                "Threat": "Security Misconfiguration",
                "Threat Severity": "High",
                "Message": "Code appears to disable security restrictions."
            })
    meta_tags = [m.get("http-equiv", "").lower() for m in html_clean.find_all("meta")]
    if not any("content-security-policy" in m for m in meta_tags):
        issues.append({
            "Threat": "Security Misconfiguration",
            "Threat Severity": "Medium",
            "Message": "No Content-Security-Policy meta tag detected."})
    return issues

def Identification_and_Authentication_failures(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        if re.search(r"(username|user|login|password)\s*=\s*['\"]", code):
            issues.append({
                "Threat": "Identification & Authentication Failures",
                "Threat Severity": "High",
                "Message": "Possible hard-coded username or password."
            })
        if "basic auth" in code or "default credentials" in code:
            issues.append({
                "Threat": "Identification & Authentication Failures",
                "Threat Severity": "Medium",
                "Message": "Basic or default authentication found in script."
            })
    for inp in html_clean.find_all("input"):
        if inp.get("type", "").lower() == "password" and not inp.get("autocomplete"):
            issues.append({
                "Threat": "Identification & Authentication Failures",
                "Threat Severity": "Low",
                "Message": "Password field missing 'autocomplete' attribute."})
    return issues

def SSRF(html_clean):
    issues = []  # List to store findings
    risky = ["localhost", "127.0.0.1", "169.254.169.254", "metadata", "internal"]

    # Check scripts, forms, and links for risky references
    for tag in html_clean.find_all(["script", "form", "a"]):
        text = (tag.get("href") or tag.get("action") or tag.get_text() or "").lower()
        for r in risky:
            if r in text:
                sev = "High" if r == "localhost" else "Critical" if r == "169.254.169.254" else "Medium"
                issues.append({
                    "Threat": "SSRF",
                    "Threat Severity": sev,
                    "Message": f"Suspicious internal reference detected: {r}"})
    return issues

def Vulnerable_and_Outdated_Components(html_clean):
    issues = []
    for script in html_clean.find_all("script", src=True):
        src = script["src"].lower()
        if "jquery-1." in src or "jquery-2." in src:
            issues.append({"Threat":"Vulnerable/Outdated Component","Threat Severity":"High","Message":"Old jQuery detected"})
        if "angular-1." in src:
            issues.append({"Threat":"Vulnerable/Outdated Component","Threat Severity":"High","Message":"Old AngularJS detected"})
        if "lodash@3" in src:
            issues.append({"Threat":"Vulnerable/Outdated Component","Threat Severity":"Medium","Message":"Old Lodash detected"})
        if "node_modules" in src or "dev-dependency" in src:
            issues.append({"Threat":"Vulnerable/Outdated Component","Threat Severity":"High","Message":"Dev dependency in production"})
        if src.startswith("http") and not script.has_attr("integrity"):
            issues.append({"Threat":"Vulnerable/Outdated Component","Threat Severity":"Medium","Message":"CDN script without integrity"})
    return issues

## END of Vulnerability Scanner section - Start of Report Writing Section ##
def csv_output(results, filename="WebSETResults.csv"):
    with open(filename, "w", newline="") as csvfile:
        fieldnames = ["Threat", "Threat Severity", "Message"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for issue in results["issues"]:
            writer.writerow(issue)

def severityGraph(results):
    amount = Counter()
    for issue in results.get("issues", []):
        severity = (issue.get("Threat Severity") or "").strip()
        if severity:
            amount[severity] += 1
    return amount

def threatCount(results):
    amount = Counter()
    for issues in results.get("issues", []):
        name = (issues.get("Threat") or "").strip()
        if name:
            amount[name] += 1
    return amount

def sevBarGraph(results, out_path= "sevBarGraph.png"):
    counts = severityGraph(results)
    if not counts:
        print("No vulnerable components found")
        return
    labels = list(counts.keys())
    values = list(counts.values())
    plt.bar(labels, values)
    plt.title("Findings by Severity")
    plt.xlabel("Severity")
    plt.ylabel("Count")
    plt.savefig(out_path)
    plt.close()

def threatCountGraph(results, out_path= "threatCountGraph.png"):
    counts = threatCount(results)
    if not counts:
        print("No vulnerable components found")
        return
    labels = list(counts.keys())
    values = list(counts.values())
    plt.bar(labels, values)
    plt.title("Findings by Threat Type")
    plt.xlabel("Threat")
    plt.ylabel("Count")
    plt.savefig(out_path)
    plt.close()

if __name__ == "__main__":
    output = scan_file("sample.html")
    print(json.dumps(output, indent=4))
    csv_output(output, "WebSETResults.csv")
    sevBarGraph(output, "severity_bar.png")
    threatCountGraph(output, "threats_bar.png")
    generate_pdf(output, "WebSET_Report.pdf", "severity_bar.png", "threats_bar.png")

    print("Results written to file")
