import json
import re
import csv
from bs4 import BeautifulSoup
def scan_file(file):
    with open(file, "r") as f:
        html_code = f.read()
    html_clean = BeautifulSoup(html_code, "html.parser")

    issues = []
    issues.extend(BrokenAccessControl(html_clean))
    issues.extend(CryptographicFailures(html_clean))
    issues.extend(sql_Injection(html_clean))
    issues.extend(InsecureDesign(html_clean))
    issues.extend(SecurityMisconfiguration(html_clean))
    issues.extend(Identification_and_Authentication_failures(html_clean))
    issues.extend(SSRF(html_clean))

    return {"issues": issues}

#@ francesca when you choose a vulnerability to start defining add it beneath line11 from the list below
"""
    issues.extend(Vulnerable_and_Outdated_Components(html_clean))
    issues.extend(Software_and_Data_integrity_Failures(html_clean))
    issues.extend(Security_logging_and_monitoring_failures(html_clean))

    result = {
        "issues": [{"Threat": "id", "Threat Severity": "High|Medium|low", "Message": "Explanation"
            }
        ]

    }
    return result
"""
#Vulnerability Scanners Go Here

def BrokenAccessControl(html_clean):
    issues = []
    BAC = html_clean.find_all("script")
    for B in BAC:
        code = B.get_text()
        lower = code.lower()

        for word in ["role", "admin", "auth", "token", "key", "secret"]:
            if word in lower:
                issues.append({
                    "Threat": "Broken Access Control", "Threat Severity": "Medium", "Message": f"Keyword  '{word}' found in script."
                })

        if re.search(r"[sS][kK]-[A-Za-z0-9]{32,}", code):
            issues.append({"Threat": "Broken Access Control", "Threat Severity": "High", "Message": "Possible API key exposed in client-side code"

            })
        if re.search(r"\b(const|let|var)\s+[A-Za-z0-9_]+\s*=\s*['\"].+['\"]", code):
            issues.append({
                "Threat": "Broken Access Control", "Threat Severity": "Medium", "Message": "Hardcoded variable assignment found in client-side code."
            })
        if "user.role" in lower and "admin" in lower:
            issues.append({
                "Threat": "Broken Access Control", "Threat Severity": "Medium", "Message": "Potential client-side role check found."
            })



    return issues

def CryptographicFailures(html_clean):
    issues = []
    CF = html_clean.find_all("script")
    for C in CF:
        code = C.get_text() or ""
        lower = code.lower()
        for algorithm in ["md5", "sha1", "des", "3des", "rc4"]:
            if algorithm in lower:
                issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "High", "Message": f"Depreciated algorithm detected: {algorithm.upper()}"})

        if "btoa(" in lower or "atob(" in lower:
            issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "Medium",
                       "Message": "Use of bota()/atob() has been detected."})
        if "math.random(" in lower:
            issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "Medium",
                       "Message": "math.random() has been used"})

        if "localstorage" in lower or "sessionstorage" in lower:
            issues.append({"Threat": "Cryptographic Failure", "Threat Severity": "Medium", "Message": "Web storage used, review if data stored is sensitive."})


        hk = re.search(r"\b(const|let|var)\s+([A-Za-z0-9_]+)\s*=\s*['\"].+['\"]", code)
        if hk:
            kss = hk.group(2).lower()
            if any(word in kss for word in ["key","salt","secret"]):
#if re.search(r"\b(const|let|var)\s+[A-Za-z0-9_]+\s*=\s*['\"].+['\"]", code):
                issues.append({
                "Threat": "Cryptographic Failure", "Threat Severity": "Medium", "Message": f"Hardcoded credential found in variable:'{kss}'"
            })
    return issues

def sql_Injection(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        sql_patterns = [
            r"select\s+.+\s+from",
            r"insert\s+into",
            r"update\s+\w+\s+set",
            r"delete\s+from",
            r"drop\s+table",
            r"union\s+select",
        ]
        for pattern in sql_patterns:
            if re.search(pattern, code):
                issues.append({
                    "Threat": "SQL Injection",
                    "Threat Severity": "High",
                    "Message": f"Possible SQL statement found in script: '{pattern}'"})
    for tag in html_clean.find_all(True):
        for attr, val in tag.attrs.items():
            val_str = str(val).lower()
            for pattern in ["select ", "insert ", "update ", "delete ", "drop ", "union "]:
                if pattern in val_str:
                    issues.append({
                        "Threat": "SQL Injection",
                        "Threat Severity": "Medium",
                        "Message": f"SQL-like text found in attribute '{attr}'."})
    return issues

def InsecureDesign(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        if "todo" in code or "fixme" in code:
            issues.append({
                "Threat": "Insecure Design",
                "Threat Severity": "Low",
                "Message": "Development note (TODO/FIXME) found in script."
            })
        if "debug" in code or "console.log" in code:
            issues.append({
                "Threat": "Insecure Design",
                "Threat Severity": "Medium",
                "Message": "Debug statements present in production code." })
    for comment in html_clean.find_all(string=lambda t: isinstance(t, str) and "<!--" in t):
        if "password" in comment.lower() or "secret" in comment.lower():
            issues.append({
                "Threat": "Insecure Design",
                "Threat Severity": "High",
                "Message": "Sensitive info mentioned in HTML comments." })
    return issues

def SecurityMisconfiguration(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        if "disable security" in code or "allow all origins" in code:
            issues.append({
                "Threat": "Security Misconfiguration",
                "Threat Severity": "High",
                "Message": "Code appears to disable security restrictions."
            })
    meta_tags = [m.get("http-equiv", "").lower() for m in html_clean.find_all("meta")]
    if not any("content-security-policy" in m for m in meta_tags):
        issues.append({
            "Threat": "Security Misconfiguration",
            "Threat Severity": "Medium",
            "Message": "No Content-Security-Policy meta tag detected."})
    return issues

def Identification_and_Authentication_failures(html_clean):
    issues = []
    for script in html_clean.find_all("script"):
        code = script.get_text().lower()
        if re.search(r"(username|user|login|password)\s*=\s*['\"]", code):
            issues.append({
                "Threat": "Identification & Authentication Failures",
                "Threat Severity": "High",
                "Message": "Possible hard-coded username or password."
            })
        if "basic auth" in code or "default credentials" in code:
            issues.append({
                "Threat": "Identification & Authentication Failures",
                "Threat Severity": "Medium",
                "Message": "Basic or default authentication found in script."
            })
    for inp in html_clean.find_all("input"):
        if inp.get("type", "").lower() == "password" and not inp.get("autocomplete"):
            issues.append({
                "Threat": "Identification & Authentication Failures",
                "Threat Severity": "Low",
                "Message": "Password field missing 'autocomplete' attribute."})
    return issues

def SSRF(html_clean):
    issues = []  # List to store findings
    risky = ["localhost", "127.0.0.1", "169.254.169.254", "metadata", "internal"]

    # Check scripts, forms, and links for risky references
    for tag in html_clean.find_all(["script", "form", "a"]):
        text = (tag.get("href") or tag.get("action") or tag.get_text() or "").lower()
        for r in risky:
            if r in text:
                sev = "High" if r == "localhost" else "Critical" if r == "169.254.169.254" else "Medium"
                issues.append({
                    "Threat": "SSRF",
                    "Threat Severity": sev,
                    "Message": f"Suspicious internal reference detected: {r}"})
    return issues

## END of Vulnerability Scanner section
def csv_output(results, filename="WebSETResults.csv"):
    with open(filename, "w", newline="") as csvfile:
        fieldnames = ["Threat", "Threat Severity", "Message"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for issue in results["issues"]:
            writer.writerow(issue)

if __name__ == "__main__":
    output = scan_file("sample.html")
    print(json.dumps(output, indent=4))
    csv_output(output, "WebSETResults.csv")
    print("Results written to file")

